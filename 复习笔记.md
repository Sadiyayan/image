

## 1. 中间件：

![Cgq2xl6ECbaAEf3bAAOZBy1Q3a0488.png](https://s0.lgstatic.com/i/image3/M01/0E/7A/Ciqah16T5Z2AWqplAAOZBy1Q3a0272.png)

### 1.1 zookeeper

```java
1.zookeeper是如何保证cp的？
  eureka如何保证ap？
  
2.分布式锁的理解：
假设有一万个请求同一个服务，这个服务经过负载均衡分布到不同ip的主机上，逻辑上是对同一个数据的数据进行修改和查询，在这部分逻辑上，加上如redis、zookeeper这样的分布式锁，可以实现分布式下高并发修改数据的正确性。

3.zookeeper分布式锁：每个请求过来在zookeeper的/lock节点下依次创建临时顺序结点，其中序号最小的节点才能得到锁，每个节点监听比他小的最大序号节点（依照zookeeper的监听机制），实现分布式锁。

4.zookeeper功能：分布式服务管理框架
1）统一命名
2）统一配置（监听节点） 监听节点数据变化//所有客户端监听zookeeper下的节点，节点变化通知客户端
3）注册中心（监听节点） 监听节点个数变化
4）软负载均衡
```



### 1.2 redis

```java
1.五种数据类型
	string
	list(类似双端队列，或者说双向链表)
	set
	hash
	zset(根据score排序value)

2.持久化方式
	rdb:
		自动备份:
			1) shutdown后自动备份入dump.rdb
			2) 每过多久变更多少次数据会写入dump.rdb
		手动备份:
			直接 save
	aof:
		所有写命令会放入到一个文件中，开机自动读取，通常设置为每过一秒更新一次数据

3.事务性质
	隔离性：所有命令都会按照顺序执行，事务在执行的过程中，不会被其他客户端送来的命令
	打断。
	
	无隔离级别：队列中的命令没有提交之前都不会被实际的执行，不存在“事务中查询要看到
	事务里的更新，事务外查询不能看到”这个头疼的问题。
	
	无原子性：冤有头债有主，如果一个命令失败，但是别的命令可能会执行成功，没有回滚。
	
4.Sentinel实现Redis的高可用
	每一台服务器中创建一个配置文件sentinel.conf，并启动，该哨兵会监控主服务器状态，一旦下线，会在slave中重新选取master作为主，不会导致因为master下线不可用而不能写数据.当原来的master重新回来之后，刚开始自立门户是master，过一小段时间，哨兵检查并将其加入到slave群中。

5.redis实现分布式锁
	redis是单线程的，命令具有原子性，是实现分布式锁的基础。
	考虑两点：1) setnx  2)设置过期时间，剩余时间小于三分之一的时候，增加过期时间
	
6.(具体底层还没有细看，需要仔细看一下，并比较一下和zookeeper的区别，为什么一个高可靠一个高性能！)
	
```

### 1.3 RabbitMQ

```java
1.MQ处理的问题
	异步处理：消息队列的终端可以同时执行多个任务，异步进行
	应用解耦：两个应用程序通过MQ逻辑连接
	流量削峰：应用秒杀（MQ可以处理大量请求）防止请求过多导致应用服务挂掉，rabbitmq采用Qos功能，设置prefetch			  的值，保证应用可以消费的消息数量，实现流量削峰；也可以在mq中设置队列的最大值，实现流量削峰
2.背景知识
	AMQP //数据传输中的协议
	JMS //Java操纵MQ的一套接口
3.rabbitMQ 高可靠 (erlang开发)，响应快-微秒级别，单机吞吐量-万级
    rabbitMQ保证高可靠即消息不丢失从三个角度考虑:
         1) 服务器消息不丢失，即路由、队列、消息都需要持久化
         2) 消费方不丢失消息，分为自动确认和手动确认，只有消费方发送ACK后，服务器队列中的消息才可以删除
         3) 生产者确保消息正确投递，主要用到confirm模式，发送后回调实现了ConfirmCallback的自定义
             的类，进行逻辑判断成功与否
  Kafka 高性能

4.rabbitmq组件
    Broker：服务器实体，可以包含多个虚拟主机！
    Virtual Host：虚拟主机，包含Queue,Exchange,和Binding机制
    	Exchange：交换机（路由），接受消息并发送给队列
    	Queue：存放消息
    	Binding：将队列和交换机绑定
    Channel：双向数据流通道，复用tcp连接，发布消息、订阅队列、接收消息都是通过channel完成的
    Connection:一个Connection中含有多个channel
        
    Publisher：生产者
    Consumer：消费者
5.工作模式
    点对点（P2P）：生产者->消息队列->消费者
        // 一个消息只能存入一个队列并只被一个消费者消费
    	流程：根据连接创建channel，由channel创建mqQueue，然后生产消费
    	模式：
    		简单模式 ：一个生产者，一个队列，一个消费者
    		工作队列模式：一个生产者，一个队列，多个消费者（多个消费者可以用线程池来代替）
        		这个模式的目的是避免简单模式下的消息被积压
    发布订阅：生产者-> 路由(依照路由属性给消息队列) -> 消息队列 -> 消费者
        // 一条（带有路由键）消息根据路由属性可以放入多个binding的队列，可能被多个消费者消费
        依照路由属性区分工作模式：
        	fanout（扇出）：消费会派给binding所有路由的队列
        	direct（定向）：依照消息的路由键和binding路由队列的路由键进行匹配
        	topic（主题）：和direct 90%一样，只是路由键支持了模糊匹配
  6. 消费端限流
      目的：当队列的消息积压过多时，防止消费端一下子获取太多消息，导致宕机，所以要限流
      原理：RabbitMQ 提供了Qos的功能，设置属性prefetch的值，表示该消费者最多会从队列中拿到的消息数量，只要消			 费者消息数量小于设置的值，队列就会向该消费者发送消息，标志是服务器收到该消息的ACK（通过消费者发回			  消息的id来告诉服务器这条消息已经被消费者成功接收了）
  7.死信
        DLX（Dead Letter Exchanges）死信交换机/死信邮箱，当消息在队列中由于某些原因没有被及时
	    消费而变成死信（dead message）后，这些消息就会被分发到DLX交换机中，而绑定DLX交换机
        的队列，称之为：“死信队列”
        原因：
             消息被拒绝，并且不再重新投递 requeue=false
		    消息超时未消费
		    达到最大队列长度
```

### 1.4Kafka

```java
1.Kafka是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统）
	// 1.kafka为什么要用zookeeper？	
    ZooKeeper 作为给分布式系统提供协调服务的工具被 kafka 所依赖。在分布式系统中，消费者需要知道有哪些生产者是	可用的，而如果每次消费者都需要和生产者建立连接并测试是否成功连接，那效率也太低了，显然是不可取的。而通过使	用 ZooKeeper 协调服务，Kafka 就能将 Producer，Consumer，Broker 等结合在一起，同时借助 ZooKeeper，	      Kafka 就能够将所有组件在无状态的条件下建立起生产者和消费者的订阅关系，实现负载均衡
    // 2.kafka为什么吞吐量大
    rabbitmq集群的所有消息都会落到leader节点上，也就是说所有消息请求都只会在一台服务器上执行，而kafka是		partition机制，请求的消息按照生产者消息分发落到不同机器的partition上，由rabbitmq的一台broker变为多台

2.kafka特点：吞吐量大-十万级，但延迟在ms级别；而rabbitmq吞吐量在万级，延迟在微秒级别
3.kafka功能：消息处理、分布式日志系统（可以常数时间时间定位到文件）
4.kafka原理
	(1)分区副本机制
		分区机制：解决单台服务器存储有限和并发限制的问题。
    	// 1. 为什么可以解决并发限制的问题：分成很多个分区后，放在不同的服务器下，可以减少对同一个服务器下的同			一个分区的访问，提高并发能力~
    	副本机制：解决数据存储的高可用问题 (follower分片的唯一功能就是用作数据备份)
    	// 2.一个分区的副本不能放在同一个服务器上，是因为如果该服务器坏掉，该分区的高可用就不存在了，如果放在			不同的服务器中，当某台机器挂掉后，其他follower副本也能迅速”转正“，开始对外提供服务~
    	// 3.任何读写操作只能操作leader副本，而不能操作follower副本，在写完leader上的数据后，会立马同步到			follower副本上，leader上副本down掉时，follower副本会转正，成为leader                               	   原因：本质上是在可用性和一致性上的取舍，如果follower副本也可以提供服务，那么性能也会有提升，但是			  会存在类似数据库的幻读、脏读问题                                                                         案例：写入一条数据到kafka主题a，消费者b从主题a消费数据，却发现消费不到，因为消费者b去读取的是			   follower分区副本，最新消息还没写入。而这个时候，另一个消费者c却可以消费到最新那条数据，因为它消费		   了leader副本。
    (2) 消息不丢失机制
    	kafka集群：分区副本机制
    	生产者：ACK机制，发送消息后等待broker的确认
    		0：无需收到broker的消息确认，即可发送下一条，这种性能最高
    		1：leader副本写入成功就认为成功了
    		2：只有分区的所有副本（leader+follower）写入成功才认为写入成功
    	消费者：默认自动提交位移（先更新位移，再消费消息，可能消费者宕机没消费消息，但消息因为位移更新没了）
    		   需要改为手动提交位移，即消费者成功消费后手动提交
    (3) 消息存储及查询机制
    	存储：partition-> segment(.index、.log、.timeindex，按照offset的容量命名)
    	查询：来了一个offset，二分定位到segment段，查找该段对应的index文件，文件中是稀疏索引，每条记录包括			   offset索引值和对应该消息记录的物理地址，根据二分定位到后再去log文件中顺序查找
    (4) 生产者消息分发
    	默认使用实现Partitioner接口的DefaultPartitioner.class类中的partition方法
    	如果自定义类实现Partitioner接口的类就使用自定义类中的partition方法
    	策略：
    		如果用户指定分区，就不会调用partition方法
    		否则调用，如果指定key，取决于key的hash值，如果不指定key，则采用轮询分发
    (5) 消费者负载均衡
    	消费者在消费时需要指定消费者的组名。
    	同一个分区中的数据，只能被一个消费者组中的一个消费者所消费。不同组的消费者可以消费同一个分区的消息。
    	目的是防止同一个组的消费者重复消费消息----并发问题。如果不同消费者消费同一个partition就需要加锁会影		响性能。
```



## 2. Java基础

### 2.1 JavaWeb

```java
1. http格式：
	请求行 请求头 空白行 请求体
	响应行 响应头 空白行 响应体
	
2. Servlet的理解

	1) 是Java语言编写的服务器端程序,换句话说,Servlet就是运行在服务器上的Java类。
	   对于每个http请求打到tomcat服务器上,需要有一个servlet进行响应处理并对应逻辑，需要自行编写对应类(实现HttpServlet接口),也就是说一个项目下可以有很多个servlet处理http的请求，而每个http请求的路径应该在web.xml中定义。
	   
	2) servlet生命周期(只有http请求来的时候才会初始化该servlet容器):
       构造方法只被调用一次，当第一次请求Servlet时调用构造方法来创建Servlet的实例。
       init方法只被调用一次，当创建好Servlet实例后立即调用该方法实现Servlet的初始化。
       service方法被多次调用，每当有请求时都会调用service方法来用于请求的响应。
       destroy方法只被调用一次，当该Servlet实例所在的Web应用被卸载前调用该方法来释放当前占用
       的资源。
       
       ！！启动服务器并不会创建servlet对象，也不会执行其中方法，只有执行http响应时才会创建
       ！！启动服务器会创建filter对象，并执行init方法
     
     3) 每个servlet都有一个ServletConfig接口用于描述Servlet本身的相关配置信息，在初始化期间用于	将信息传递给Servlet配置对象。可以理解为这个config是单独为每个servlet使用的。
        而服务器会在启动时，为每个项目创建唯一的一个ServletContext对象，用于实现多个Servlet之间
	   的信息共享和通信。可以理解为n个servlet共享context对象里的信息。
3. filter过滤器是向 Web 应用程序的请求和响应处理添加功能的 Web 服务组件
   listener用来监听Servlet容器产生的事件并进行相应的处理
   
4.手写JDK动态代理
// 接口          
public interface JDKProxy {
    void test();
}

public class JDKProxyImpl implements JDKProxy {
    // 目标对象
    public static JDKProxy jdkProxy=new JDKProxyImpl();
    @Override
    public void test() {
        System.out.println("实现类的重写方法");
    }
    public JDKProxy createProxy(){
        // 生成目标对象的代理对象
        // 参数1：目标对象的类加载器，参数2：目标对象实现的接口，参数3：InvocationHandler接口的实现类
        return (JDKProxy) Proxy.newProxyInstance(jdkProxy.getClass().getClassLoader(), 		jdkProxy.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            // proxy为当前的代理对象引用
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("前动态代理的方法执行了");
                Object invoke = method.invoke(jdkProxy, args);
                System.out.println("后动态代理的方法执行了");
                return invoke;
            }
        });
    }

    public static void main(String[] args) {
        System.out.println(jdkProxy.getClass());
        JDKProxy jdkProxy1=new JDKProxyImpl().createProxy();
        jdkProxy1.test();
        System.out.println("--------");
        jdkProxy.test();
    }
}
```

### 2.2 JavaSE

```java
1.hash冲突的解决方法
    开放地址法：
    	线性探测散列：即某一个位置被占就往后跳一个格子看是否有位置，没有就继续跳
    	平方探测散列：增量依次是，1方，-1方，2方，-2方...
    链地址(就是链表，HashMap的处理方式)
    再哈希法：当hash冲突时，用另一个hash函数计算hash值
    
2.为什么重写 equals 时必须重写 hashCode 方法？
    如果两个对象相等，则 hashcode 一定也是相同的，那么调用equals方法一定返回true，如果重写了equals方法，hashcode没有重写，此时会对象相等但hashcode不等的情况，以hashset为例，放入这两个对象的时候会先计算hashcode，hashcode都不等了就会放入不同的桶中，但是两个对象实际是相等的，应该放在同一个桶中。
    
3.JDK JRE JVM的关系
    JDK = JRE + (javac,javap等一些列工具)
    JRE = JVM + 运行类库
    
4.Java 是编译与解释共存的原因
    编译：1) java文件需要先编译成class文件 2) JVM JIT编译热点代码 变成机器码存入方法区中
    解释：执行器一条一条字节码解释执行
    
5. java的泛型是伪泛型，在运行期间，所有的泛型信息都会被擦掉
    List<Integer> list = new ArrayList<>();
    //这里直接添加会报错
    list.add("a");
    Class<? extends List> clazz = list.getClass();
    Method add = clazz.getDeclaredMethod("add", Object.class);
    //但是通过反射添加，是可以的
    add.invoke(list, "kl");

6.关于String
    // 常量池
    1) 定义：
        通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中
        字符串常量池是不会存储相同内容的字符串的
        String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的		   String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用		   String.intern时性能会大幅下降。
    2) 使用：
    	直接使用双引号声明出来的String对象会直接存储在常量池中。 
		如果不是用双引号声明的String对象,可以使用String提供的intern()方法，会将堆区对象的地址放入池中
    	Java7以前字符串常量池放在永久代,Java7移入堆中(静态变量也移入堆中)
    3) 关于intern方法：
    	当调用intern方法时，如果池子里已经包含了一个与这个String对象相等的字符串，正如equals(Object)	方法所确定的，那么池子里的字符串的引用会被返回。否则，这个String对象的引用地址会被copy一份并添加到池中
    	Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间

7.接口和抽象类的区别
    类：抽象类单继承，接口多实现
    变量：抽象类可以有成员变量，接口只能有常量（默认public static final修饰）
    方法：抽象类有构造方法，可以有成员方法，抽象方法可有可无
    	 接口无构造方法，只有抽象方法，必须被重写
8.object中的方法：
    hashcode、equals、wait、notify、toString、getClass、finalize、clone
    clone默认是浅拷贝，Object类里面没有实现cloneable接口，所以在使用这个方法时，实体类需要实现cloneable接口，并重写clone方法，默认写super.clone()就行

9.// 反射
    利用反射运行时分析类并执行类中方法
    获取class对象的方法：
    1) 类型.class
    2) 引用/对象的.getClass()
    3) Class.forName("类全路径") // 会对类进行静态初始化
    4) ClassLoader.loadClass("类全路径") // 并不会对类进行静态初始化
10.静态代理和动态代理的区别：
       JDK动态代理的过程：首先有三个东西，接口、目标对象、代理对象，代理对象通过Proxy.newInstance(目标对象的类加载器，目标对象的接口，InvocationHandler的实现类)得到，当代理对象调用接口中的方法时，就会调用InvocationHandler中重写的invoke方法进行动态增强
       但JDK动态代理只能代理实现了接口的类，Cglib可以代理没有实现接口的类也可以实现代理接口的类
       //区别：
        静态代理中，接口一旦增加方法，代理类也需要重写方法，任务量很重，动态代理不用
        动态代理的代理类字节码是运行时JVM自动生成并加载的，静态代理的代理类class文件编译后就有了
11.ArrayList分析
        1)和linkedList的区别：一个数组一个双向链表，其次围绕增删查改的时间复杂度来说，空间复杂度arraylist体现在需要预留一部分空间，linkedlist的复杂度在于每个节点需要维护前后节点的地址
        2) 初始化：如果指定了容量则初始化该容量的Object数组，否则该数组为空
        3) 扩容分析:如果此时的size等于数组长度，即需要扩容了(minCapacity=size+1)，将minCapacity传入扩容方法，会计算newCapacity为此时数组长度的1.5倍，Ⅰ如果还是小于minCapacity，那么扩容大小应为minCapacity，Ⅱ 如果newCapacity大于MAX_ARRAY_SIZE，判断minCapacity是否大于MAX_ARRAY_SIZE，如果大于newCapacity=Integer.MAX_VALUE，小于newCapacity=MAX_ARRAY_SIZE，最后返回newCapacity。扩容是调用Arrays.copyOf()方法的。
            //看下面这个
           当数组为空时，第一次加入一个元素，会调用grow方法扩容，计算newCapacity为minCapacity的1.5倍，但此时minCapacity为0，newCapacity仍小于等于minCapacity，所以此时会让newCapacity=10。此后直到添加到11个元素，又需要扩容了，newCapacity=1.5*数组length，如果newCapacity大于MAX_ARRAY_SIZE，就需要判断minCapacity是否大于MAX_ARRAY_SIZE，如果仍然大于它，newCapacity=Integer.MAX_VALUE，否则newCapacity=MAX_ARRAY_SIZE。最后返回newCapacity。扩容是调用Arrays.copyOf()方法的
            
12.HashMap的分析：
         初始化为16，每次扩容2倍，如果指定容量大小，则会把该容量变成2的幂次方，默认负载因子为0.75，当总容量达到12个时候就会resize，涉及到rehash比较耗费性能
         JDK1.8 及以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64(即大于等于64会转化红黑树)，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间
         //hashmap长度是2的幂次方的原因：
         当计算出对象的hashcode后，需要计算在数组下标中的位置，即hashcode%length,如果length长度为2的幂次方，hashcode%length == hashcode&(length-1),这种采用位运算的方式会加快运算
         // 并发情况下hashmap可能会导致链表死循环，主要是rehash中的transfer方法的问题
   //扩容分析:put方法实际调用了putval方法
   首先第一次put时候会触发resize为16，然后通过(n - 1) & hash计算出数组下标即桶的位置。
   如果该位置无数据则直接创建新节点插入，
   如果没有进行接下来的判断， 
      Ⅰ如果该位置的hash值以及key和待插入的key和hash相等，代表这就是我们要找的entry， 
      Ⅱ如果该节点是树节点，调用红黑树插入 
      Ⅲ 如果不是树那就是链表，采用尾插法，循环遍历，如果找到了key的hash并且key相等的entry，遍历结束，如果找到末尾，则插入新节点，并判断当前如果新插入的元素是第八个的话就会调用treeifyBin，决定是否转化成红黑树(table数组长度大于等于64才可以转换)
      如果找到的entry节点不为空，就把newval替代给oldval
   最后如果插入元素大于了threshold，就会调用resize方法
```

### 2.3 JVM

<img src="https://raw.githubusercontent.com/Sadiyayan/image/master/JVM/fcf40fb3-9dc8-454e-a45b-6d12c61c6f59.png" style="zoom: 67%;" />

```
1.问丁总String 常量池的笔记
2.执行引擎s
```

### 2.4 并发

```
currenthashmap
```



## 3.数据库

### 3.1 MySQL

```java
1.mysql使用b+树而不用b树的原因
	1) 根据局部性原理，需要进行磁盘预读，b+树可以做到，同理，范围查询也可以做到（叶子节点之间有双向指针）。
	2) 除叶子节点外，只包含索引没有data，所以一次IO可以索引更大的数据范围，减少需要的IO次数。
	
2.为什么建议InnoDB表必须建主键，并且推荐使用整型并且自增的主键？
	innodb采取聚集索引，即B+树的叶子节点会存放data（某一行的所有数据），而myisam（非聚集索引）叶子节点存放的是某一行数据的地址，对于主键（唯一非空索引）叶子节点存放所有数据，而普通列的索引只存放对应行的主键值，如果表不建主键的话，mysql自动帮我们找一列做主键建索引，如果没有符合的列，那就有mysql自己维护一个新的列作为主键索引。		总的来说，如果不建索引，MySQL后台还是会为我们维护主键，这相当于增大了开销。
	整型：查找时候做比较很快，而且占空间小。
	自增：插入节点时，在某一叶子节点的后边直接加入即可，方便索引排序。而使用uuid这种的话，可能会导致叶子节点分裂，会影响性能。
	
3.最左前缀原则：
	如果使用联合索引多列，言遵从最左前缀法则，指的是查询从索引的最左列开始并且不跳过索引中的项。
	
4.bufferpool
	mysql的bufferopool存有叶子节点的数据值，采用LRU置换。

5.事务相关问题
	1)并发问题
	脏读：读取了其他并发事务未提交的数据
	不可重复读：读取了其他并发事务提交的数据。针对update和delete
	幻读：读取了其他并发事务提交的数据。针对insert
	
	2)四种隔离级别：读未提交，读已提交，可重复读，序列化
	
	//表锁与行锁的区别：锁定粒度，加锁效率，冲突概率，并发性能
	
	3)事务隔离级别的实现方式
		LBCC
		MVCC
	4)锁的种类
		共享锁（读锁）和排他锁（写锁）--可以应用于行和表（二者都可），都是lock的实现，应用于事务（不是）
		意向共享锁和意向排他锁（均是表锁）--针对共享行锁和排他行锁，在获取时，需要首先获取它们的意向锁，用来判断此表是否含有行锁。
		记录锁、间隙锁、临键锁（记录锁+间隙锁）
		
	5)MVCC底层原理
		Ⅰ注：begin不是一个事务的起点，在执行到第一个操纵innodb表的语句时（增删改，读的事务id不一样），事务才算启动并向mysql申请事务id，并严格按照事务的启动顺序分配事务id
		Ⅱmysql数据库表会为数据库表多两列--事务id和回滚指针
		Ⅲ在RC隔离级别下，是每个SELECT都会获取最新的read view；而在RR隔离级别下，则是当事务中的第一个SELECT请求才创建read view。read view由所有未提交事务id数组（数组中最小的为min_id）和已创建事务的最大事务id（max_id）组成，查询时根据版本链（undolog）的顺序读取trx_id和readview中的事务id进行比较从而查询到结果。
		Ⅳ版本链比对规则：
		if(trx_id<min_id)说明是已提交事务，数据可见
		if(trx_id>max_id)说明是未创建事务，数据不可见
		if(min_id<=trx_id<=max_id)两种情况
		  a 如果trx_id在数组中，数据不可见，但如果当前select的事务id和trx_id相同，则可见
		  b 如果trx_id不在数组中，说明是已提交事务生成的，数据可见
		Ⅴ对于delete可以认为是update的特殊情况，也会将数据复制一份，然后在记录的头信息中的delete_flag设置为true，此后查询到此记录时，则会检查标志位，为true
6.//慢查询如何解决
            
```

## 4.计算机基础

### 4.1 操作系统

```java
1.什么是软中断、硬中断

2.IO多路复用：在服务端有两种 Socket 文件，每个客户端接入之后会形成一个客户端的 Socket 文件，客户端 Socket 文	件的文件描述符会存入服务端 Socket 文件。通过这种方式，一个线程可以通过读取服务端 Socket 文件中的内容拿到	所有的客户端 Socket。这样一个线程就可以负责响应所有客户端的 I/O，这个技术称为 I/O 多路复用
	1) 首先建立连接，服务端ServerSocket,bind,listen,accept,客户端Socket connect发送连接请求，服务端listen收到请求，建立socket半连接队列与连接队列，接着accpet获取连接队列里面的socket，此时服务端进程有了Socket文件（绑定了一个端口号对应一个应用程序）的文件描述符。多路复用就是进程里维护了一个socket文件描述符集合
	2) Socket文件内有一个inode指向内核中的Socket结构，该结构中有发送和接收的缓冲区，缓冲区为空，该进程就会被阻塞（放入到阻塞队列中）
	3) select过程:客户端发送数据到网卡，网卡通过DMA拷贝到内核的网卡缓冲区，DMA发送中断信号给CPU，根据中断信号向量找到网卡的中断处理程序，该程序会将网卡缓冲区的内容依照端口号拷贝到内核中Socket结构的读缓冲区，并将该阻塞进程移入就绪队列，等待CPU执行。执行时，读取该进程的Socket文件描述符集合，并用bitmap表示，通过select()函数传入到内核中，内核会依照读缓冲区有数据的socket修改bitmap，并拷贝到用户态程序中，用户程序依照bitmap找到对应的socket文件进行数据的处理。（注：每次读数据需要两次bitmap的拷贝和遍历，并且下次还要重新置位bitmap，因为bitmap两次拷贝后发生变化了，比较浪费资源）
	问题：1.描述符的限制、2.每次调用 select 都需要从用户空间把描述符集合拷贝到内核空间，当描述符集合变大之		  后，用户空间和内核空间的内存拷贝会导致效率低下
	4) poll 基于链表存储，能解决socket文件描述符大小限制的问题，依然不能解决线性遍历以及用户空间和内核空间		 的低效数据拷贝问题
	5) epoll过程:①红黑树解决文件描述符限制问题和查找慢的问题，②把红黑树集合放入到内核中，避免全部拷贝，③使		用双向链表缓存就绪的 socket，只需要拷贝这个双向链表到用户空间，再遍历就行
	6) reactor模式:
		
3. NIO,BIO的具体实现		
```

### 4.2 计算机网络

#### 4.2.1 HTTP

```java
1.Http 超文本传输协议
    超文本指的是⽂字、图⽚、⾳频、视频等「超⽂本」数据
    传输指的是两点之间双向传输，协议就是共同遵守的规范
2.http状态码
    2xx：服务器成功处理了客户端请求
    	200：响应头有数据 204：响应头无数据
    3xx：发生重定向
    	302：请求资源在，但是需要用另一个url访问
    4xx：客户端发送的报文有误，服务器无法处理
    	400：客户端请求报文有误，比较笼统的错误
    	403：服务器禁止访问资源，请求没有错
    	404：请求的资源在服务器没有找到
    5xx：客户端请求报文正确，服务器内部处理发生错误
    	500：服务器错误，笼统错误，和400一样
    	502(bad gateway)：服务器作为网关或者代理返回的错误码，自身正常，但后端服务器发生错误
    	503：服务器当前忙，暂时无法响应
3.get和post区别
    // http中安全指的是不会破坏服务器的资源，幂等指多次执行相同操作结果都是相同的
    get是从服务器获取资源(文本，页面，视频)，幂等且安全
    post向uri指定的资源提交数据，数据放在请求体中(和get的概念正好相反) 不幂等不安全
4.http/1.0短连接，即每发一次请求都要建立一次tcp连接，是串行发送的，即要等到下一次请求响应才可以继续发送下一个请求
  http/1.1长连接，支持管道传输，(长连接使得管道传输成为可能---可以并行发送请求，按照顺序依次响应处理(需要排队),如果队头请求被阻塞，后续请求也无法处理)
    //总结
    1.1相对于1.0的改进和问题：
    	改进：长连接、支持管道传输
    	问题：1) header未压缩，会发送重复的内容 2)管道传输会引起队头阻塞
   	2针对1.1不足的改进：
    	改进：建立在https的基础上
    	1) 压缩头，会去重：HPACK算法，客户端和服务器维护一个头信息表，针对字段生成索引号，以后只发索引号
    	2) 响应数据成为数据流，不再按照顺序响应，流中会标记有编号，解决了队头阻塞问题
    	问题：多个http请求复用tcp连接，一旦发生丢包，触发TCP重传机制，就会阻塞所有的http请求
    // 1.1 和 2 的总结，两个问题都是基于tcp的问题
    	1.1中管道传输会引起队头阻塞
    	2 复用tcp连接，一旦丢包会阻塞所有的http请求
    
5.https
    在http和tcp中间加入了TLS安全协议，在tcp三次握手之后还需要TLS的握手
    // 功能
    信息加密：通过混合加密(对称加密和非对称加密)
    校验机制：保证数据不被篡改，通过摘要算法
    身份证书：将服务器公匙放入数字证书中，保证访问的网址是你想要访问的，而不是假的
    
    // TLS四次握手的过程？
```

## 5.Spring体系

### 5.1 SpringMVC

```java
1.组件执行流程
	1)前端控制器根据请求地址由处理器映射器找到具体的处理器，再返回给前端控制器。
	2)前端控制器通过处理器适配器调用具体的处理器并返回modelandview(也可只有view，即逻辑视图)
	3)前端控制器将ModelAndView传给视图解析器，将逻辑视图拼接前后缀转化为具体的物理视图（对拼接	好的物理视图转发），生成view对象返回给前端控制器
    //注：
    	Ⅰ：逻辑视图本质也是转发，如果指定转发或者重定向的关键字，路径必须完整，而且不再走视图			解析器了
    	Ⅱ：model的本质是向一个request域中存放数据，重定向会使其失效
	4)前端控制器将模型数据填充至view中，并响应给用户
	
2.常用注解
	@RequestMapping() // 添加到方法和类上，也就是处理器映射器找的东西
		value：用于指定请求的URL。它和path属性的作用是一样的
		method：用来限定请求的方式
		params：用来限定请求参数的条件
		
	// 以下三个注解都是用于方法中的形参上，第一个最常用
	@RequestParam // 解决请求的参数name名称与Controller的方法参数名称不一致问题
		defaultValue 设置参数默认值
		name 匹配页面传递参数的名称
		required 设置是否必须传递参数，默认值为true；如果设置了默认值，值自动改为false
	@RequestHeader // 获取请求头的数据
	@CookieValue // 获取某一cookie中的数据。
    
    @SessionAttributes //向request域存入的key为value时，同步到session域中，作用在类上
   
    @RequestBody  
    	该注解用于Controller的方法的形参声明，当使用ajax提交并指定contentType为json串形式时，通过				HttpMessageConverter接口转换为对应的POJO对象。// 作用于形参
    @ResponseBody
    	该注解用于将Controller的方法返回的对象或集合，通过HttpMessageConverter接口转换为json串，如果是		String字符串则直接返回，不再走视图解析器。//作用于方法上
    
    // Restful风格
    @PathVariable :用来接收RESTful风格请求地址中占位符的值
    @RestController = @Controller + @Responsebody
```

### 5.2 SpringBoot

```java
1.功能：起步依赖、自动配置
    //Spring Boot 是所有基于 Spring 开发的项目的起点
    //配置文件加载顺序：yml>yaml>properties,也就是说properties的配置文件会覆盖前两种文件的相同属性值
    起步依赖实现原理：任何springboot项目都会继承父项目spring-boot-starter-parent，该项目会继承父项目spring-boot-dependencies，在该项目中，会在<properties>标签中定义依赖版本属性值，在<dependencyManagement>标签中定义好了在自己源项目中引入了依赖的坐标的版本号，所以源项目只需要依赖的坐标，不需要指定版本号即可引入所有起步依赖。
    
2.注解：
    1)由配置文件属性注入过程理解：
    	实体类加上@Component生成对象放入到IOC容器中，依照以下两个注解的内容从配置文件中赋予对象变量的值
    @ConfigurationProperties(prefix = "person")
    // 将配置文件中以person开头的属性值通过setXX()方法注入到实体类对应属性中，实体类需要加上@Component生成对		象放入IOC容器中
    @Value("${person.id}")
    // 直接将配置文件中的person.id的值对注解下的变量进行注入，无需走setXX()方法
    
    2)自定义配置
    @PropertySource("classpath:test.properties") // 加载自定义配置文件
    @Configuration // 表明是一个配置类，SpringBoot会自动扫描，替代了传统的xml文件
    
    3)@SpringBootApplication下的注解
   
 3.springboot不支持jsp的原因：
    在Jetty和Tomcat容器中，Spring Boot应用被打包成war文件可以支持JSP。但Spring Boot默认使用嵌入式Servlet容器以JAR包方式进行项目打包部署，这种JAR包方式不支持JSP。
```

### 5.3 SpringCloud

```java
// 可以通过连接数据库来生成实体类，右键选择scripted extension 
// @Table(name="xxx") 该注解将实体类映射到数据库表，name指定了表的名称可以和实体类名字不一样，除此之外我的理解是该实体有了此注解后可以融合mybatisplus，mapper层继承basemapper的泛型指定了实体，相当于指定了表，方便开发，但目前没看过源码，无从考究。
1.微服务与SOA的不同：
    SOA同样是拆分服务，分布式项目，但粒度比微服务大，同时对服务的治理功能没有微服务的功能多
    
2.SpringCloud和Dubbo的对比：
    协议：SpringCloud实现由feign组件采取http协议进行微服务调用，dubbo基于RPC默认采用TCP，效率更高一些
    功能：SpringCloud的功能组件很全，一站式，以SpringBoot为基石，即依赖管理和自动配置的优势方便开发，而Dubbo		的功能提供并不全，例如服务注册与发现需要zookeeper完成。
    
3.核心概念
    Spring Cloud其实是一套规范，具体实现有SCN和SCA
    (1) 服务注册与服务发现：zookeeper(CP)、eureka(AP，集群无主从之分)、nacos(AP和CP切换)
    	   服务注册中心可以支持服务数量动态伸缩，服务提供者和注册中心维持心跳机制，某一服务宕机了，可以剔除。
    	原理：消费者和服务提供者都向注册中心注册，消费者先拉取提供者列表，再去调用提供者，实现了解耦，方便动		  态伸缩服务提供者，除此之外注册中心还提供服务检测机制，将宕机的服务剔除并通知对应的消费者。消费者定期		拉取服务列表并实现负载均衡和熔断的实现。
    		
    (2) 负载均衡
    	服务熔断和服务降级：熔断是降级的一种策略 而降级是对于整体的负荷的考虑,资源不够用了就暂停非重要资源的		    访问。 降级又分为主动降级和被动降级,主动降级:大促时主动关闭非核心业务;被动降级:熔断降级、限流降级等 		 熔断在一段时间内服务失败率达到阈值触发熔断,触发熔断后的一段时间内客户端将直接返回熔断干预的返回结果,		并且会尝试熔断恢复。
        流控是对外部来的大流量进行控制，熔断降级(熔断一般针对下游服务的响应时间)的视角是对内部问题进行处理！！
    (3) 链路追踪
    API网关
        
4.SCN组件
      1) eureka
        //心跳检测:
		30s微服务会向注册中心续约一次，注册中心90s没收到续约就会剔除该微服务（这里两个参数都是在客户端置），		服务端默认是60s检查一次，如果发现距离上次续约的时间已经过了90s，那么就会剔除该服务
        //客户端缓存：
        消费者会在本地缓存从注册中心拉取的服务提供者（IP:port），即使eureka全部宕机，仍可以访问服务提供者。默		认30S拉取服务最新的注册表并缓存到本地
        //元数据：
        分为标准元数据和自定义元数据，都存在server instance中
        //自我保护机制
        自我保护模式是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的		运行，就是说健康或者不健康的微服务都会保存，这种情况下发生在5分钟内超过85%的客户端节点都没有正常的心	   跳，此时就会触发自我保护机制，这时的eureka服务器可以接受来自客户端的请求（前提是可以接受到），但内部的		元数据不同同步到其他集群节点。主要目的就是说可能是server自身的网络有问题，而不是微服务有问题，怕“误	   杀”。当重新收到心跳数恢复阀值以上时，该EurekaServer节点就会自动的退出自我保护模式。和zookeeper相比，	   只有一半以上节点存活，集群才可用，否则处于瘫痪状态。
      2) ribbon
         //负载均衡分类：
            客户端和服务端，服务端包括nginx，也就是客户端直接访问nginx的地址，由nginx做负载均衡，路由到目标地址；客户端包括ribbon，就是由客户端直接从一堆地址在均衡的基础上选择一个进行访问。
         //负载均衡策略（主要记三种，其实有很多种）：
            RoundRobinRule：轮询策略，如果超过十次没获取到则为空
            ZoneAvoidanceRule：区域权衡策略（默认策略），先过滤再轮询，过滤掉超时、连接多、和不符合zone要求		     的节点
            BestAvailableRule：最小连接数策略，遍历serverList，选取出可用的且连接数最小的一个server
         // 简单原理：
            就是在restemplate里面加了一个拦截器，然后在拦截器里面加了负载均衡算法，实现客户端的负载均衡
         // 用法：
            在生成restemplate对象的方法上添加一个注解@LoadBalanced
      3) Hystrix
         // 舱壁模式：
            所有加@HystrixCommand注解的方法，当有请求到来时，都会进入到hystrix维护的一个默认为10的线程池			   中，很有可能线程池满了，请求进不去直接调用失败，但服务提供者是可用的情况，所以需要在
            @HystrixCommand属性中设置threadPoolKey，代表开启了舱壁模式（实现线程隔离），一个threadPoolKey			  代表一个线程池。
         // 工作流程：
            当出现调用错误时，开一个默认10s的时间窗，如果达到最小连接请求数，并且达到错误的阈值，则服务提供者			 进入熔断状态，此时进入自我修复机制，会默认开启一个5s的活动窗口，在此期间，hystrix会放行一个到达的			 请求，如果可以连接上服务提供者，则取消熔断状态。
            这里一共四个参数：时间窗、最小连接数、错误阈值、活动窗口
      4) Feign
         // 组成：
            以接口注解的方式调用http请求，Feign = RestTemplate + Ribbon + Hystrix
            启动类使用注解@EnableFeignClients，feign的依赖包中包括了Ribbon + Hystrix的依赖
            @FeignClient(name=相同的名字就会出现报错, fallback=xxx.class),所以最好将调用一个微服务的信息		      定义在一个Feign接口中。
         // 对ribbon的支持
            Feign已经ribbon的依赖和自动配置，默认ribbon就是打开状态
            Feign默认的请求处理超时时长1s，如果配置Ribbon的超时，则会以Ribbon的为准，就是说Feign超时时间就			   是Ribbon的超时时间
         // 对Hystrix的支持
            默认Hystrix不开启，需要开始Feign对Hystrix的支持
            熔断也有超时时间，调用服务提供者是否超时是按照Feign/Hystrix中设置的超时时间小的来算
      5) GateWay(引入的是web-flux模块而不是Springmvc)// Spring Cloud官方的组件
         // 组成
            主要包括路由和过滤器，路由属性包括断言、服务id、服务uri和条件过滤，其中uri支持动态路由，即			   ip+host不能写死，格式：lb://微服务名称
		   过滤器是找到路由后和对应微服务之间的一层，分为pre和post，分别对应调用前过滤和响应过滤。类型分为全			  局过滤器和单个路由过滤器。
            “pre”类型过滤器中可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器			中可以做响应内容、响应头的修改、日志的输出、流量监控
         // 流程
           客户端向Spring Cloud GateWay发出请求，然后在GateWay Handler Mapping中找到与请求相匹配的路由，			  将其发送到GateWay Web Handler；Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻			 辑，然后返回（分为pre和post）。
      6) Config（自动刷新需要用到Spring Cloud Bus）
           分布式配置管理方案，分为客户端、服务端
           //流程：
               在github一个项目中配置一个对应的文件，server端可以直接访问到（即使文件变化，也可以再次拉取				  到，因为二者直接通信），client端配置server的信息，既可以拉取到对应的配置信息，需要将配置文件			    名由application.yml -> bootstrap.yml，bootstrap.yml启动项目时会加载配置server的数据并缓存			    到本地，但在server端的文件改变后，客户端得到的依然是缓存中的数据。解决方法如下刷新策略：
           //刷新策略：
               手动刷新：client端使用 post+refresh，从server端(而不是client端本地缓存)获取最新数据
               自动刷新：思路就是一次通知，处处生效，访问server端 post+bus refresh
               		过程：在server和client间加入消息总线spring cloud bus，当server端使用post+bus 							refresh后，会发送消息给bus，bus会触发消息队列（rabbitmq/kafka），此时队列会把消						 息发送给binding的微服务，告诉他们使用post+refresh去server端拉取最新的配置信息，						 实现了一次通知处处生效
5.SCA组件
     1) Nacos = eureka + config + bus
     2) Sentinel = Hystrix + 更多功能
             
```

### 5.4 ShardingJDBC

```java
1.分库分表
    1) 原因：单机存储容量遇到瓶颈；连接数,处理能力达到上限。
    2) 分类：// 分库分表的意思是分成库或者分成表
    	垂直分库：根据表的业务不同，将一个库中的表分到各个服务器的数据库中，一定程度上可以解决并发性能
    	水平分库：将一张表的数据分到不同的数据库中，一定程度上可以解决并发性能，如果分库后的库还很大，接着考				  虑水平分表
    	垂直分表：将一张表的数据按照字段分成多张表
    	水平分表：将一张表的数据分到同一个数据库中的多张表里
    	// 总结：水平分可以解决单机存储容量问题，分库可以解决并发问题
    	// 首先应该考虑的是索引和缓存，如果数据量持续上涨再考虑分库还是分表
    
2.主从复制:
	通过搭建主从架构, 将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效	  的避免由数据更新导致的行锁
3.分库分表的问题：
    事务一致性问题
    跨节点关联的问题（关联查询）
    分页排序查询的问题
    主键避重问题
    公共表的问题
4.ShardingJDBC
    轻量级Java框架，在Java的JDBC层提供额外的服务
    使用shardingJDBC前需要提前对数据库分库分表，应用程序通过引入的shardingJDBC依赖操作分库分表后的数据库和表
    相比mycat，它是一个中间件应用，实现了mysql的协议，代理了mysql
5.ShardingJDBC的使用
    流程(针对配置文件)：指定数据源的信息(哪台主机、哪台数据库) -> 指定数据节点(数据源的哪张表，也就是指定逻辑					 表的具体信息) -> 分片策略(指定分片键和算法) -> [指定分布式ID生成算法(雪花算法)]
    1) 水平分库和水平分表流程：本质上是一张表先进行水平分库，然后因为单机的数据库的数据量太大，才会导致继续水平分表。分库需要指定多个数据源信息（只是水平分表一个数据源就ok，因为只在一个数据库上），数据节点就是所有的实际表信息（都映射为一张逻辑表，和本质里的一张表相对应），最后针对逻辑表指定分库分表的路由策略
    2) 垂直分库的流程：几个库就指定几个数据源，由于是垂直分库，有很多的逻辑表，所以数据节点信息需配置多个，分片规则根据具体是否分来配置
    3) 读写分离流程：主库从库分别配置数据源信息，指定逻辑库，即哪个是主库哪个是从库，可以理解由逻辑库整合，由逻辑库指定逻辑表的信息（配置数据节点）
    4) 操作公共表
```

### 5.5 Mybatis

```java
1.Mybatis的基本原理   
    (1)
    // 该步骤只是加载了配置文件的输入流，包括核心配置文件和xxxmapper.xml
    InputStream is = Resources.getResourceAsStream("SqlMapConfig.xml");
    (2)
    // 生成SqlSessionFactory工厂对象
    // 使用dom4j对上述配置文件解析，xxxmapper中的每一项都会被封装成一个MappedStatement对象(包括sql、形参类型、返回参数)，总体封装成一个map集合，key为xxxmapper.id,如usermapper.findAll
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
    (3)
    // 生成SqlSession会话对象
    //如果设置为true则执行增删改都会持久化，相当于直接提交事务，不设置需要在最后commit
    SqlSession sqlSession = sqlSessionFactory.openSession([true]);
    (4)
    // sqlSession并不会操作数据库底层是委派给Executor执行器执行JDBC的操作，sql等参数由对应的MappedStatement对象获取MappedStatement对象由"UserMapper.delete"从步骤(2)map集合中获取
    // SqlSession十分强大,包括selectOne、selectList、insert、update、delete、commit、rollback方法
    sqlSession.delete("UserMapper.delete", 50);

    // DML语句，手动提交事务
    sqlSession.commit();
    // 释放资源
    sqlSession.close();

2.Mybatis代理开发的原理
    sqlMapConfig.xml中配置<package name="org.mybatis.builder"/>是为了加载和xxxmapper接口同名包的xxxmapper.xml文件，此时配置<mapper resource="org/mybatis/builder/userMapper.xml"/>即直接引入xxxmapper.xml的方式也可以，但是不能做到简化，需要一个一个引入。
    
    @MapperScan作用：
    	生成代理对象存入IOC容器中(关于Spring项目中什么时候加载xxxmapper.xml文件没有弄清楚，目前个人理解应该是在配置生成mapper代理对象的路径时，根据代理开发会扫描同样路径下的xxxmapper.xml文件，如果有则由sqlSessionFactory加载生成mappedstatement存入map集合)
    
    InputStream is = Resources.getResourceAsStream("SqlMapConfig.xml");
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
    SqlSession sqlSession = sqlSessionFactory.openSession([true]);

    // 基于JDK动态代理生成UserMapper的代理对象
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    // 代理对象执行接口方法时会调用InvacationHandler中重写的invoke方法，底层还是调用了
    // sqlSession.selectOne(xxxMapper.id,paramter)等相应的方法，再调用执行器执行JDBC操作
    List<User> list = userMapper.findAll();
```



### 5.6 Mybatis Plus

```java
1. 针对实体类的注解(类或者字段加对应的注解)
    @TableName("xxx") //mp根据继承basemapper泛型的类来找到数据源中库里的表名，如果表名不一致，需要加上该注解
    @TablePrefix("tb_") // 表示映射数据库中以"tb_"开头+实体类名字的表名
    @TableId(type = IdType.AUTO) //指定id类型为自增，mq在该注解中定义了一些主键生成策略
    // 对象中的属性名和字段名不⼀致的问题（⾮驼峰）,本质就是把表中的字段名as 成实体类的字段名
    @TableField(value = "表中字段名") 
    // 表中没有实体类字段名称
    @TableField(exist = false)
    // 不查询实体类的某一字段
    @TableField(select = false)
 
2.mp sql自动注入的原理
    // 自定义的方法并没有实验如何注入，等自己写项目的时候debug一下？
    // 猜测自定义的方法和mybatis的实现原理一样
    ISqlInjector负责SQL的注⼊⼯作，它是⼀个接⼝，AbstractSqlInjector是它的实现类
    在AbstractSqlInjector的inspectInject()方法中会循环注入basemapper中的方法，以xxxmapper.方法名为key，mapperstatement对象为value注入map集合中，此后代理对象调用basemapper接口中的方法时，就会触发动态代理的机制，调用InvacationHandler中重写的invoke方法，该方法会去map集合中根据key找到value，再找到对应的sql，由sqlsession原始方法执行

3.常用配置信息
    // 加载核心配置文件
	mybatis-plus.config-location = classpath:mybatis-config.xml
    // 加载mapper对应的xml文件
    //classpath* 除了加载本工程下的文件，还会加载本工程所有依赖下classpath对应的文件
    mybatis-plus.mapper-locations = classpath*:mybatis/*.xml
```

## 6.项目

### 6.1 微服务教育项目

```java
// 遇到的问题
	eureka客户端的依赖和web依赖需要各自引入，不要引入父工程
    数据库的依赖单独引入，如果引入父工程，会在eureka中需要datasource
    停掉某一端口的方法:
		netstat -ano | findstr 7001 //查找pid
         taskkill /F /PID xxx // 根据pid杀死进程
1.eureka注册中心 //7001
2.广告微服务 // 8001
    设置广告位（promotion_ad）,轮播组件有图片的url，点击图片会跳转link（图片和跳转在前端div属性设置的）
    侧边广告位：纯前端代码
            
3.网关微服务// 9001
    给广告微服务加了网关 // 为啥要加？？
            
4.用户模块
       1)SSO(single sign on)单点登录：
         问题：不同tomcat服务器的session肯定不一样，如果是个微服务项目，想要登录的话，登录一次只会保存在一个服务器的session域中，其他服务器无法获得，还是需要重新登录，很麻烦，所以不能用session解决
         解决：SSO可以在一个浏览器中登录一次，访问其他地址时刷新就可以实现自动登录
```



# 一些不错的博客/Github 推荐

- SnailClimb 的 Github ：[https://github.com/Snailclimb](https://github.com/Snailclimb "https://github.com/Snailclimb") 。（自荐一波哈！主要专注在 Java 基础和进阶、Spring、Spring Boot、Java 面试这方面。）
- 徐靖峰个人博客 ：[https://www.cnkirito.moe/](https://www.cnkirito.moe/ "https://www.cnkirito.moe/")（探讨 Java 生态的知识点，内容覆盖分布式服务治理、微服务、性能调优、各类源码分析）
- 田小波：[http://www.tianxiaobo.com/](http://www.tianxiaobo.com/ "http://www.tianxiaobo.com/") （Java 、Spring 、MyBatis 、Dubbo）
- 周立的博客： [http://www.itmuch.com/](http://www.itmuch.com/ "http://www.itmuch.com/")（Spring Cloud、Docker、Kubernetes，及其相关生态的技术）
- Hollis: [https://www.hollischuang.com/](https://www.hollischuang.com/ "https://www.hollischuang.com/") (Java 后端)
- 方志朋的专栏 ： [https://www.fangzhipeng.com/](https://www.fangzhipeng.com/ "https://www.fangzhipeng.com/") （Java 面试 Java 并发 openresty kubernetes Docker 故事 )
- 纯洁的微笑 : [http://www.ityouknow.com/](http://www.ityouknow.com/ "http://www.ityouknow.com/") （Java、SpringBoot、Spring Cloud）
- 芋道源码： [http://www.iocoder.cn/](http://www.iocoder.cn/ "http://www.iocoder.cn/") (专注源码)。

